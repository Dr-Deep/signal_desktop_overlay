--- node_modules/app-builder-lib/out/core.d.ts	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/core.d.ts	2021-02-25 15:27:45.338537000 +0100
@@ -18,6 +18,7 @@ export declare class Platform {
     buildConfigurationKey: string;
     nodeName: NodeJS.Platform;
     static MAC: Platform;
+    static FREEBSD: Platform;
     static LINUX: Platform;
     static WINDOWS: Platform;
     constructor(name: string, buildConfigurationKey: string, nodeName: NodeJS.Platform);
--- node_modules/app-builder-lib/out/core.js	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/core.js	2021-02-25 15:06:35.598679000 +0100
@@ -64,6 +64,9 @@ class Platform {
       case Platform.LINUX.nodeName:
         return Platform.LINUX;
 
+      case Platform.FREEBSD.nodeName:
+        return Platform.FREEBSD;
+
       default:
         throw new Error(`Unknown platform: ${name}`);
     }
@@ -73,6 +76,7 @@ class Platform {
 
 exports.Platform = Platform;
 Platform.MAC = new Platform("mac", "mac", "darwin");
+Platform.FREEBSD = new Platform("freebsd", "freebsd", "freebsd");
 Platform.LINUX = new Platform("linux", "linux", "linux");
 Platform.WINDOWS = new Platform("windows", "win", "win32");
 
--- node_modules/app-builder-lib/out/electron/ElectronFramework.js	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/electron/ElectronFramework.js	2021-02-25 15:45:09.936840000 +0100
@@ -126,8 +126,14 @@ async function beforeCopyExtraFiles(options) {
   const packager = options.packager;
   const appOutDir = options.appOutDir;
 
-  if (packager.platform === _index().Platform.LINUX) {
+  if (packager.platform === _index().Platform.FREEBSD) {
     if (!(0, _platformPackager().isSafeToUnpackElectronOnRemoteBuildServer)(packager)) {
+      const freebsdPackager = packager;
+      const executable = path.join(appOutDir, freebsdPackager.executableName);
+      await (0, _fsExtra().rename)(path.join(appOutDir, "electron"), executable);
+    }
+  } else if (packager.platform === _index().Platform.LINUX) {
+    if (!(0, _platformPackager().isSafeToUnpackElectronOnRemoteBuildServer)(packager)) {
       const linuxPackager = packager;
       const executable = path.join(appOutDir, linuxPackager.executableName);
       await (0, _fsExtra().rename)(path.join(appOutDir, "electron"), executable);
@@ -178,7 +184,9 @@ class ElectronFramework {
   }
 
   getDefaultIcon(platform) {
-    if (platform === _index().Platform.LINUX) {
+    if (platform === _index().Platform.FREEBSD) {
+      return path.join((0, _pathManager().getTemplatePath)("icons"), "electron-freebsd");
+    } else if (platform === _index().Platform.LINUX) {
       return path.join((0, _pathManager().getTemplatePath)("icons"), "electron-linux");
     } else {
       // default icon is embedded into app skeleton
--- node_modules/app-builder-lib/out/frameworks/LibUiFramework.d.ts	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/frameworks/LibUiFramework.d.ts	2021-02-25 15:17:16.027569000 +0100
@@ -13,6 +13,7 @@ export declare class LibUiFramework implements Framewo
     constructor(version: string, distMacOsAppName: string, isUseLaunchUi: boolean);
     prepareApplicationStageDirectory(options: PrepareApplicationStageDirectoryOptions): Promise<void>;
     private prepareMacosApplicationStageDirectory;
+    private prepareFreeBSDApplicationStageDirectory;
     private prepareLinuxApplicationStageDirectory;
     afterPack(context: AfterPackContext): Promise<void>;
     getMainFile(platform: Platform): string | null;
--- node_modules/app-builder-lib/out/frameworks/LibUiFramework.js	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/frameworks/LibUiFramework.js	2021-02-25 15:18:42.846438000 +0100
@@ -79,6 +79,8 @@ class LibUiFramework {
 
     if (platform === _core().Platform.MAC) {
       await this.prepareMacosApplicationStageDirectory(packager, options);
+    } else if (platform === _core().Platform.FREEBSD) {
+      await this.prepareFreeBSDApplicationStageDirectory(options);
     } else if (platform === _core().Platform.LINUX) {
       await this.prepareLinuxApplicationStageDirectory(options);
     }
@@ -102,6 +104,16 @@ class LibUiFramework {
   `)]);
   }
 
+  async prepareFreeBSDApplicationStageDirectory(options) {
+    const appOutDir = options.appOutDir;
+    await (0, _builderUtil().executeAppBuilder)(["proton-native", "--node-version", this.version, "--platform", "freebsd", "--arch", options.arch, "--stage", appOutDir]);
+    const mainPath = path.join(appOutDir, options.packager.executableName);
+    await writeExecutableMain(mainPath, `#!/bin/sh
+  DIR=$(dirname "$0")
+  "$DIR/node" "$DIR/app/${options.packager.info.metadata.main || "index.js"}"
+  `);
+  }
+
   async prepareLinuxApplicationStageDirectory(options) {
     const appOutDir = options.appOutDir;
     await (0, _builderUtil().executeAppBuilder)(["proton-native", "--node-version", this.version, "--platform", "linux", "--arch", options.arch, "--stage", appOutDir]);
@@ -134,7 +146,7 @@ class LibUiFramework {
   }
 
   isUseLaunchUiForPlatform(platform) {
-    return platform === _core().Platform.WINDOWS || this.isUseLaunchUi && platform === _core().Platform.LINUX;
+    return platform === _core().Platform.WINDOWS || this.isUseLaunchUi && platform === _core().Platform.LINUX || this.isUseLaunchUi && platform === _core().Platform.FREEBSD;
   }
 
   getExcludedDependencies(platform) {
--- node_modules/app-builder-lib/out/freebsdPackager.d.ts	2021-04-02 09:23:24.675766000 +0200
+++ node_modules/app-builder-lib/out/freebsdPackager.d.ts	2021-02-25 18:59:06.722395000 +0100
@@ -0,0 +1,11 @@
+import { Arch } from "builder-util";
+import { Target } from "./core";
+import { FreeBSDConfiguration } from "./options/freebsdOptions";
+import { Packager } from "./packager";
+import { PlatformPackager } from "./platformPackager";
+export declare class FreeBSDPackager extends PlatformPackager<FreeBSDConfiguration> {
+    readonly executableName: string;
+    constructor(info: Packager);
+    get defaultTarget(): Array<string>;
+    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void): void;
+}
--- node_modules/app-builder-lib/out/freebsdPackager.js	2021-04-02 09:23:28.124821000 +0200
+++ node_modules/app-builder-lib/out/freebsdPackager.js	2021-02-26 14:27:01.446038000 +0100
@@ -0,0 +1,207 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+exports.FreeBSDPackager = void 0;
+
+function _builderUtil() {
+  const data = require("builder-util");
+
+  _builderUtil = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _sanitizeFilename() {
+  const data = _interopRequireDefault(require("sanitize-filename"));
+
+  _sanitizeFilename = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _core() {
+  const data = require("./core");
+
+  _core = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _platformPackager() {
+  const data = require("./platformPackager");
+
+  _platformPackager = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _ArchiveTarget() {
+  const data = require("./targets/ArchiveTarget");
+
+  _ArchiveTarget = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _FreeBSDTargetHelper() {
+  const data = require("./targets/FreeBSDTargetHelper");
+
+  _FreeBSDTargetHelper = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _targetFactory() {
+  const data = require("./targets/targetFactory");
+
+  _targetFactory = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+class FreeBSDPackager extends _platformPackager().PlatformPackager {
+  constructor(info) {
+    super(info, _core().Platform.FREEBSD);
+    const executableName = this.platformSpecificBuildOptions.executableName;
+    this.executableName = executableName == null ? this.appInfo.sanitizedName.toLowerCase() : (0, _sanitizeFilename().default)(executableName);
+  }
+
+  get defaultTarget() {
+    return ["tar.xz"];
+  }
+
+  createTargets(targets, mapper) {
+    let helper;
+
+    const getHelper = () => {
+      if (helper == null) {
+        helper = new (_FreeBSDTargetHelper().FreeBSDTargetHelper)(this);
+      }
+
+      return helper;
+    };
+
+    let remoteBuilder = null;
+
+    for (const name of targets) {
+      if (name === _core().DIR_TARGET) {
+        continue;
+      }
+
+      const targetClass = (() => {
+        switch (name) {
+          case "tar.xz":
+            // https://github.com/electron-userland/electron-builder/issues/2313
+            mapper(name, outDir => new (_ArchiveTarget().ArchiveTarget)(name, outDir, this, true));
+            break;
+
+          default:
+            return null;
+        }
+      })();
+
+      mapper(name, outDir => {
+        if (targetClass === null) {
+          return (0, _targetFactory().createCommonTarget)(name, outDir, this);
+        }
+
+        const target = new targetClass(name, this, getHelper(), outDir);
+
+        if (process.platform === "win32" || process.env._REMOTE_BUILD) {
+          if (remoteBuilder == null) {
+            remoteBuilder = new (_RemoteBuilder().RemoteBuilder)(this);
+          } // return remoteBuilder.buildTarget(this, arch, appOutDir, this.packager)
+
+
+          return new RemoteTarget(target, remoteBuilder);
+        }
+
+        return target;
+      });
+    }
+  }
+
+}
+
+exports.FreeBSDPackager = FreeBSDPackager;
+
+class RemoteTarget extends _core().Target {
+  constructor(target, remoteBuilder) {
+    super(target.name, true
+    /* all must be scheduled in time (so, on finishBuild RemoteBuilder will have all targets added - so, we must set isAsyncSupported to true (resolved promise is returned)) */
+    );
+    this.target = target;
+    this.remoteBuilder = remoteBuilder;
+    this.buildTaskManager = new (_builderUtil().AsyncTaskManager)(this.remoteBuilder.packager.info.cancellationToken);
+  }
+
+  get options() {
+    return this.target.options;
+  }
+
+  get outDir() {
+    return this.target.outDir;
+  }
+
+  async finishBuild() {
+    await this.buildTaskManager.awaitTasks();
+    await this.remoteBuilder.build();
+  }
+
+  build(appOutDir, arch) {
+    const promise = this.doBuild(appOutDir, arch);
+    this.buildTaskManager.addTask(promise);
+    return promise;
+  }
+
+  async doBuild(appOutDir, arch) {
+    _builderUtil().log.info({
+      target: this.target.name,
+      arch: _builderUtil().Arch[arch]
+    }, "scheduling remote build");
+
+    await this.target.checkOptions();
+    this.remoteBuilder.scheduleBuild(this.target, arch, appOutDir);
+  }
+
+}
+
+function toAppImageOrSnapArch(arch) {
+  switch (arch) {
+    case _builderUtil().Arch.x64:
+      return "x86_64";
+
+    case _builderUtil().Arch.ia32:
+      return "i386";
+
+    case _builderUtil().Arch.armv7l:
+      return "arm";
+
+    case _builderUtil().Arch.arm64:
+      return "arm_aarch64";
+
+    default:
+      throw new Error(`Unsupported arch ${arch}`);
+  }
+} 
+// __ts-babel@6.0.4
+//# sourceMappingURL=freebsdPackager.js.map
--- node_modules/app-builder-lib/out/index.d.ts	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/index.d.ts	2021-02-25 15:16:14.794611000 +0100
@@ -16,6 +16,7 @@ export { AppXOptions } from "./options/AppXOptions";
 export { MsiOptions } from "./options/MsiOptions";
 export { CommonWindowsInstallerConfiguration } from "./options/CommonWindowsInstallerConfiguration";
 export { NsisOptions, NsisWebOptions, PortableOptions, CommonNsisOptions } from "./targets/nsis/nsisOptions";
+export { FreeBSDConfiguration, CommonFreeBSDOptions, FreeBSDTargetSpecificOptions } from "./options/freebsdOptions";
 export { LinuxConfiguration, DebOptions, CommonLinuxOptions, LinuxTargetSpecificOptions, AppImageOptions } from "./options/linuxOptions";
 export { SnapOptions } from "./options/SnapOptions";
 export { Metadata, AuthorMetadata, RepositoryInfo } from "./options/metadata";
--- node_modules/app-builder-lib/out/options/freebsdOptions.d.ts	2021-04-02 09:23:37.187938000 +0200
+++ node_modules/app-builder-lib/out/options/freebsdOptions.d.ts	2021-02-25 15:15:10.425561000 +0100
@@ -0,0 +1,107 @@
+import { PlatformSpecificBuildOptions, TargetConfigType, TargetSpecificOptions } from "../index";
+export interface FreeBSDConfiguration extends CommonFreeBSDOptions, PlatformSpecificBuildOptions {
+    /**
+     * Target package type: list of `AppImage`, `snap`, `deb`, `rpm`, `freebsd`, `pacman`, `p5p`, `apk`, `7z`, `zip`, `tar.xz`, `tar.lz`, `tar.gz`, `tar.bz2`, `dir`.
+     *
+     * electron-builder [docker image](/multi-platform-build#docker) can be used to build FreeBSD targets on any platform.
+     *
+     * Please [do not put an AppImage into another archive](https://github.com/probonopd/AppImageKit/wiki/Creating-AppImages#common-mistake) like a .zip or .tar.gz.
+     * @default AppImage
+     */
+    readonly target?: TargetConfigType;
+    /**
+     * The maintainer. Defaults to [author](/configuration/configuration#Metadata-author).
+     */
+    readonly maintainer?: string | null;
+    /**
+     * The vendor. Defaults to [author](/configuration/configuration#Metadata-author).
+     */
+    readonly vendor?: string | null;
+    /**
+     * The executable name. Defaults to `productName`.
+     * Cannot be specified per target, allowed only in the `freebsd`.
+     */
+    readonly executableName?: string | null;
+    /**
+     * The path to icon set directory or one png file, relative to the [build resources](/configuration/configuration#MetadataDirectories-buildResources) or to the project directory. The icon filename must contain the size (e.g. 32x32.png) of the icon.
+     * By default will be generated automatically based on the macOS icns file.
+     */
+    readonly icon?: string;
+    /**
+     * backward compatibility + to allow specify fpm-only category for all possible fpm targets in one place
+     * @private
+     */
+    readonly packageCategory?: string | null;
+}
+export interface CommonFreeBSDOptions {
+    /**
+     * The [short description](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Description).
+     */
+    readonly synopsis?: string | null;
+    /**
+     * As [description](/configuration/configuration#Metadata-description) from application package.json, but allows you to specify different for FreeBSD.
+     */
+    readonly description?: string | null;
+    /**
+     * The [application category](https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry).
+     */
+    readonly category?: string | null;
+    /**
+     * The mime types in addition to specified in the file associations. Use it if you don't want to register a new mime type, but reuse existing.
+     */
+    readonly mimeTypes?: Array<string> | null;
+    /**
+     * The [Desktop file](https://developer.gnome.org/integration-guide/stable/desktop-files.html.en) entries (name to value).
+     */
+    readonly desktop?: any | null;
+    /**
+     * The executable parameters. Pass to executableName
+     */
+    readonly executableArgs?: Array<string> | null;
+}
+export interface FreeBSDTargetSpecificOptions extends CommonFreeBSDOptions, TargetSpecificOptions {
+    /**
+     * Package dependencies.
+     */
+    readonly depends?: Array<string> | null;
+    /**
+     * The compression type.
+     * @default xz
+     */
+    readonly compression?: "gz" | "bzip2" | "xz" | null;
+    readonly icon?: string;
+    /**
+     * The package category.
+     */
+    readonly packageCategory?: string | null;
+    readonly vendor?: string | null;
+    readonly maintainer?: string | null;
+    readonly afterInstall?: string | null;
+    readonly afterRemove?: string | null;
+    /**
+     * *Advanced only* The [fpm](https://github.com/jordansissel/fpm/wiki#usage) options.
+     *
+     * Example: `["--before-install=build/deb-preinstall.sh", "--after-upgrade=build/deb-postinstall.sh"]`
+     */
+    readonly fpm?: Array<string> | null;
+}
+export interface DebOptions extends FreeBSDTargetSpecificOptions {
+    /**
+     * Package dependencies. Defaults to `["gconf2", "gconf-service", "libnotify4", "libappindicator1", "libxtst6", "libnss3"]`.
+     */
+    readonly depends?: Array<string> | null;
+    /**
+     * The [package category](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Section).
+     */
+    readonly packageCategory?: string | null;
+    /**
+     * The [Priority](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Priority) attribute.
+     */
+    readonly priority?: string | null;
+}
+export interface AppImageOptions extends CommonFreeBSDOptions, TargetSpecificOptions {
+    /**
+     * The path to EULA license file. Defaults to `license.txt` or `eula.txt` (or uppercase variants). Only plain text is supported.
+     */
+    readonly license?: string | null;
+}
--- node_modules/app-builder-lib/out/options/freebsdOptions.js	2021-04-02 09:23:39.518096000 +0200
+++ node_modules/app-builder-lib/out/options/freebsdOptions.js	2021-02-25 15:15:26.346362000 +0100
@@ -0,0 +1,7 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+// __ts-babel@6.0.4
+//# sourceMappingURL=freebsdOptions.js.map
--- node_modules/app-builder-lib/out/packager.js	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/out/packager.js	2021-02-25 15:51:36.361409000 +0100
@@ -348,6 +348,10 @@ class Packager {
       processTargets(_index().Platform.MAC, options.mac);
     }
 
+    if (options.freebsd != null) {
+      processTargets(_index().Platform.FREEBSD, options.freebsd);
+    }
+
     if (options.linux != null) {
       processTargets(_index().Platform.LINUX, options.linux);
     }
@@ -692,6 +696,9 @@ class Packager {
 
           return new helperClass(this);
         }
+
+      case _index().Platform.FREEBSD:
+        return new (require("./freebsdPackager").FreeBSDPackager)(this);
 
       case _index().Platform.LINUX:
         return new (require("./linuxPackager").LinuxPackager)(this);
--- node_modules/app-builder-lib/out/targets/FreeBSDTargetHelper.d.ts	2021-04-02 09:24:17.338321000 +0200
+++ node_modules/app-builder-lib/out/targets/FreeBSDTargetHelper.d.ts	2021-02-25 15:40:54.315613000 +0100
@@ -0,0 +1,22 @@
+import { FreeBSDTargetSpecificOptions } from "..";
+import { FreeBSDPackager } from "../freebsdPackager";
+import { IconInfo } from "../platformPackager";
+export declare const installPrefix = "/opt";
+export declare class FreeBSDTargetHelper {
+    private packager;
+    private readonly iconPromise;
+    private readonly mimeTypeFilesPromise;
+    maxIconPath: string | null;
+    constructor(packager: FreeBSDPackager);
+    get icons(): Promise<Array<IconInfo>>;
+    get mimeTypeFiles(): Promise<string | null>;
+    private computeMimeTypeFiles;
+    private computeDesktopIcons;
+    getDescription(options: FreeBSDTargetSpecificOptions): string;
+    writeDesktopEntry(targetSpecificOptions: FreeBSDTargetSpecificOptions, exec?: string, destination?: string | null, extra?: {
+        [key: string]: string;
+    }): Promise<string>;
+    computeDesktopEntry(targetSpecificOptions: FreeBSDTargetSpecificOptions, exec?: string, extra?: {
+        [key: string]: string;
+    }): Promise<string>;
+}
--- out/targets/FreeBSDTargetHelper.js	2021-04-02 09:24:19.848598000 +0200
+++ node_modules/app-builder-lib/out/targets/FreeBSDTargetHelper.js	2021-02-25 15:41:21.052360000 +0100
@@ -0,0 +1,231 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.FreeBSDTargetHelper = exports.installPrefix = void 0;
+
+function _builderUtil() {
+  const data = require("builder-util");
+
+  _builderUtil = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _fsExtra() {
+  const data = require("fs-extra");
+
+  _fsExtra = function () {
+    return data;
+  };
+
+  return data;
+}
+
+function _lazyVal() {
+  const data = require("lazy-val");
+
+  _lazyVal = function () {
+    return data;
+  };
+
+  return data;
+}
+
+const installPrefix = "/opt";
+exports.installPrefix = installPrefix;
+
+class FreeBSDTargetHelper {
+  constructor(packager) {
+    this.packager = packager;
+    this.iconPromise = new (_lazyVal().Lazy)(() => this.computeDesktopIcons());
+    this.mimeTypeFilesPromise = new (_lazyVal().Lazy)(() => this.computeMimeTypeFiles());
+    this.maxIconPath = null;
+  }
+
+  get icons() {
+    return this.iconPromise.value;
+  }
+
+  get mimeTypeFiles() {
+    return this.mimeTypeFilesPromise.value;
+  }
+
+  async computeMimeTypeFiles() {
+    const items = [];
+
+    for (const fileAssociation of this.packager.fileAssociations) {
+      if (!fileAssociation.mimeType) {
+        continue;
+      }
+
+      const data = `<mime-type type="${fileAssociation.mimeType}">
+  <glob pattern="*.${fileAssociation.ext}"/>
+    ${fileAssociation.description ? `<comment>${fileAssociation.description}</comment>` : ""}
+  <icon name="x-office-document" />
+</mime-type>`;
+      items.push(data);
+    }
+
+    if (items.length === 0) {
+      return null;
+    }
+
+    const file = await this.packager.getTempFile(".xml");
+    await (0, _fsExtra().outputFile)(file, '<?xml version="1.0" encoding="utf-8"?>\n<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">\n' + items.join("\n") + "\n</mime-info>");
+    return file;
+  } // must be name without spaces and other special characters, but not product name used
+
+
+  async computeDesktopIcons() {
+    const packager = this.packager;
+    const iconDir = packager.platformSpecificBuildOptions.icon;
+    const sources = iconDir == null ? [] : [iconDir];
+    const commonConfiguration = packager.config;
+    const icnsPath = (commonConfiguration.mac || {}).icon || commonConfiguration.icon;
+
+    if (icnsPath != null) {
+      sources.push(icnsPath);
+    } // need to put here and not as default because need to resolve image size
+
+
+    const result = await packager.resolveIcon(sources, (0, _builderUtil().asArray)(packager.getDefaultFrameworkIcon()), "set");
+    this.maxIconPath = result[result.length - 1].file;
+    return result;
+  }
+
+  getDescription(options) {
+    return options.description || this.packager.appInfo.description;
+  }
+
+  async writeDesktopEntry(targetSpecificOptions, exec, destination, extra) {
+    const data = await this.computeDesktopEntry(targetSpecificOptions, exec, extra);
+    const file = destination || (await this.packager.getTempFile(`${this.packager.appInfo.productFilename}.desktop`));
+    await (0, _fsExtra().outputFile)(file, data);
+    return file;
+  }
+
+  async computeDesktopEntry(targetSpecificOptions, exec, extra) {
+    if (exec != null && exec.length === 0) {
+      throw new Error("Specified exec is empty");
+    } // https://github.com/electron-userland/electron-builder/issues/3418
+
+
+    if (targetSpecificOptions.desktop != null && targetSpecificOptions.desktop.Exec != null) {
+      throw new Error("Please specify executable name as linux.executableName instead of linux.desktop.Exec");
+    }
+
+    const packager = this.packager;
+    const appInfo = packager.appInfo;
+    const productFilename = appInfo.productFilename;
+    const executableArgs = targetSpecificOptions.executableArgs;
+
+    if (exec == null) {
+      exec = `${installPrefix}/${productFilename}/${packager.executableName}`;
+
+      if (!/^[/0-9A-Za-z._-]+$/.test(exec)) {
+        exec = `"${exec}"`;
+      }
+
+      if (executableArgs) {
+        exec += " ";
+        exec += executableArgs.join(" ");
+      }
+
+      exec += " --no-sandbox %U";
+    }
+
+    const desktopMeta = {
+      Name: appInfo.productName,
+      Exec: exec,
+      Terminal: "false",
+      Type: "Application",
+      Icon: packager.executableName,
+      // https://askubuntu.com/questions/367396/what-represent-the-startupwmclass-field-of-a-desktop-file
+      // must be set to package.json name (because it is Electron set WM_CLASS)
+      // to get WM_CLASS of running window: xprop WM_CLASS
+      // StartupWMClass doesn't work for unicode
+      // https://github.com/electron/electron/blob/2-0-x/atom/browser/native_window_views.cc#L226
+      StartupWMClass: appInfo.productName,
+      ...extra,
+      ...targetSpecificOptions.desktop
+    };
+    const description = this.getDescription(targetSpecificOptions);
+
+    if (!(0, _builderUtil().isEmptyOrSpaces)(description)) {
+      desktopMeta.Comment = description;
+    }
+
+    const mimeTypes = (0, _builderUtil().asArray)(targetSpecificOptions.mimeTypes);
+
+    for (const fileAssociation of packager.fileAssociations) {
+      if (fileAssociation.mimeType != null) {
+        mimeTypes.push(fileAssociation.mimeType);
+      }
+    }
+
+    for (const protocol of (0, _builderUtil().asArray)(packager.config.protocols).concat((0, _builderUtil().asArray)(packager.platformSpecificBuildOptions.protocols))) {
+      for (const scheme of (0, _builderUtil().asArray)(protocol.schemes)) {
+        mimeTypes.push(`x-scheme-handler/${scheme}`);
+      }
+    }
+
+    if (mimeTypes.length !== 0) {
+      desktopMeta.MimeType = mimeTypes.join(";") + ";";
+    }
+
+    let category = targetSpecificOptions.category;
+
+    if ((0, _builderUtil().isEmptyOrSpaces)(category)) {
+      const macCategory = (packager.config.mac || {}).category;
+
+      if (macCategory != null) {
+        category = macToFreeBSDCategory[macCategory];
+      }
+
+      if (category == null) {
+        // https://github.com/develar/onshape-desktop-shell/issues/48
+        if (macCategory != null) {
+          _builderUtil().log.warn({
+            macCategory
+          }, "cannot map macOS category to FreeBSD. If possible mapping is known for you, please file issue to add it.");
+        }
+
+        _builderUtil().log.warn({
+          reason: "linux.category is not set and cannot map from macOS",
+          docs: "https://www.electron.build/configuration/linux"
+        }, "application FreeBSD category is set to default \"Utility\"");
+
+        category = "Utility";
+      }
+    }
+
+    desktopMeta.Categories = `${category}${category.endsWith(";") ? "" : ";"}`;
+    let data = `[Desktop Entry]`;
+
+    for (const name of Object.keys(desktopMeta)) {
+      data += `\n${name}=${desktopMeta[name]}`;
+    }
+
+    data += "\n";
+    return data;
+  }
+
+}
+
+exports.FreeBSDTargetHelper = FreeBSDTargetHelper;
+const macToFreeBSDCategory = {
+  "public.app-category.graphics-design": "Graphics",
+  "public.app-category.developer-tools": "Development",
+  "public.app-category.education": "Education",
+  "public.app-category.games": "Game",
+  "public.app-category.video": "Video;AudioVideo",
+  "public.app-category.utilities": "Utility",
+  "public.app-category.social-networking": "Network;Chat",
+  "public.app-category.finance": "Office;Finance"
+}; 
+// __ts-babel@6.0.4
+//# sourceMappingURL=FreeBSDTargetHelper.js.map
--- node_modules/app-builder-lib/scheme.json	2021-04-02 09:16:49.757000000 +0200
+++ node_modules/app-builder-lib/scheme.json	2021-02-25 15:13:04.711285000 +0100
@@ -928,6 +928,7 @@
         "platform": {
           "enum": [
             "darwin",
+            "freebsd",
             "linux",
             "mas",
             "win32"
